<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>RustyGPT Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "rust";
            const default_dark_theme = "coal";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">RustyGPT Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/vanna/rusty_gpt" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rustygpt-documentation"><a class="header" href="#rustygpt-documentation">RustyGPT Documentation</a></h1>
<p>Welcome! This mdBook describes the RustyGPT workspace in depth: how the server and clients are structured, how the
PostgreSQL-backed features behave, and how to operate the platform locally or in shared environments.</p>
<p><em>Start with the guides to get a local environment running, then dive into the reference and architecture chapters for precise
APIs and design notes.</em></p>
<h2 id="quick-navigation"><a class="header" href="#quick-navigation">Quick navigation</a></h2>
<ul>
<li><a href="guide/quickstart.html">Quickstart</a> – configure and launch the server, web client, and CLI.</li>
<li><a href="guide/local-dev.html">Local development</a> – watcher workflows, debugging tools, and environment variables.</li>
<li><a href="reference/api.html">REST API</a> – endpoint catalogue for conversations, streaming, authentication, and admin features.</li>
<li><a href="architecture/service-topology.html">Service topology</a> – how the Axum server, Yew SPA, PostgreSQL, and SSE stream hub fit together.</li>
</ul>
<h2 id="what-rustygpt-ships-today"><a class="header" href="#what-rustygpt-ships-today">What RustyGPT ships today</a></h2>
<p>RustyGPT focuses on a cohesive Rust stack:</p>
<ul>
<li><code>rustygpt-server</code> exposes REST + SSE endpoints with cookie-based auth (<code>handlers/auth.rs</code>), rate limiting
(<code>middleware/rate_limit.rs</code>), and OpenAPI documentation (<code>openapi.rs</code>).</li>
<li><code>rustygpt-web</code> is a Yew SPA that consumes the server API via <code>src/api.rs</code> and renders threaded conversations, presence, and
typing indicators.</li>
<li><code>rustygpt-cli</code> shares the same models as the server, providing commands for login, conversation inspection, SSE following, and
OpenAPI generation (<code>src/commands</code>).</li>
<li><code>rustygpt-shared</code> houses configuration loading, llama.cpp bindings, and the data transfer objects used across all crates.</li>
</ul>
<p>Each documentation section links back to the relevant modules so you can cross-reference behaviour with the implementation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guide-overview"><a class="header" href="#guide-overview">Guide Overview</a></h1>
<p>These walkthroughs assume you are starting from a fresh checkout. They show how to configure <code>config.toml</code>, run the
Axum server, keep the Yew frontend hot-reloading, and validate that authentication + streaming work end to end.</p>
<ul>
<li><a href="guide/quickstart.html">Quickstart</a> bootstraps the database, enables feature flags, and walks through the setup flow.</li>
<li><a href="guide/local-dev.html">Local Development</a> documents the <code>just</code> recipes, watcher processes, and debugging tips.</li>
</ul>
<p>For conceptual background jump to <a href="guide/../concepts/index.html">Concepts</a>; for task-specific runbooks see <a href="guide/../howto/index.html">How-to</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quickstart"><a class="header" href="#quickstart">Quickstart</a></h1>
<blockquote>
<p>TL;DR – copy <code>config.example.toml</code>, enable the feature flags you need, start PostgreSQL, run the Axum server, complete the
<code>/api/setup</code> flow, then bring up the Yew frontend and CLI.</p>
</blockquote>
<h2 id="1-prerequisites"><a class="header" href="#1-prerequisites">1. Prerequisites</a></h2>
<ul>
<li>Rust toolchain (<code>rustup default stable</code>), <code>cargo</code>, and <a href="https://just.systems"><code>just</code></a></li>
<li><a href="https://trunkrs.dev/"><code>trunk</code></a> for the web client (<code>cargo install trunk</code>)</li>
<li>PostgreSQL 15+ running locally (the provided <code>docker-compose.yaml</code> exposes one at <code>postgres://tinroof:rusty@localhost:5432/rusty_gpt</code>)</li>
<li>Optional: llama.cpp-compatible model files if you plan to exercise assistant streaming</li>
</ul>
<p>Fetch dependencies once:</p>
<pre><code class="language-bash">cargo fetch --workspace
</code></pre>
<h2 id="2-configure-the-server"><a class="header" href="#2-configure-the-server">2. Configure the server</a></h2>
<p>Create <code>config.toml</code> and adjust it for your environment:</p>
<pre><code class="language-bash">cp config.example.toml config.toml
</code></pre>
<p>At minimum set:</p>
<pre><code class="language-toml">[db]
url = "postgres://tinroof:rusty@localhost/rustygpt_dev"

[features]
auth_v1 = true
sse_v1 = true
well_known = true
</code></pre>
<p><code>rustygpt-shared::config::server::Config</code> supports TOML/YAML/JSON files and environment overrides (e.g.
<code>RUSTYGPT__SERVER__PORT=8080</code>). See <a href="guide/../reference/config.html">Configuration</a> for the complete matrix of keys.</p>
<h2 id="3-start-postgresql"><a class="header" href="#3-start-postgresql">3. Start PostgreSQL</a></h2>
<p>If you are using Docker Compose:</p>
<pre><code class="language-bash">docker compose up postgres -d
</code></pre>
<p>On server startup the bootstrap runner executes every SQL script under <code>scripts/pg/{schema,procedures,indexes,seed}</code> in order.
The seed stage enables feature flags and inserts the default rate-limit profile (<code>conversation.post</code>).</p>
<h2 id="4-run-the-backend"><a class="header" href="#4-run-the-backend">4. Run the backend</a></h2>
<p>Either launch directly:</p>
<pre><code class="language-bash">cargo run -p rustygpt-server -- serve --port 8080
</code></pre>
<p>or use the helper recipe that also builds configuration if needed:</p>
<pre><code class="language-bash">just run-server
</code></pre>
<p>The process listens on <code>http://127.0.0.1:8080</code>. Health probes are available at <code>/api/healthz</code> and <code>/api/readyz</code>.</p>
<h2 id="5-complete-initial-setup"><a class="header" href="#5-complete-initial-setup">5. Complete initial setup</a></h2>
<p>The first authenticated user is created by POSTing to <code>/api/setup</code>:</p>
<pre><code class="language-bash">curl -X POST http://127.0.0.1:8080/api/setup \
  -H 'Content-Type: application/json' \
  -d '{"username":"admin","email":"admin@example.com","password":"change-me"}'
</code></pre>
<p>Subsequent calls return <code>400</code> once a user already exists.</p>
<h2 id="6-start-the-web-client"><a class="header" href="#6-start-the-web-client">6. Start the web client</a></h2>
<p>In a new terminal:</p>
<pre><code class="language-bash">cd rustygpt-web
trunk serve
</code></pre>
<p>The SPA proxies <code>/api/*</code> requests to the backend. After logging in you should see:</p>
<ul>
<li>Conversation list populated by <code>GET /api/conversations/{conversation_id}/threads</code></li>
<li>Thread view that streams updates from <code>/api/stream/conversations/{conversation_id}</code></li>
<li>Presence and typing indicators driven by <code>ConversationStreamEvent</code> payloads</li>
</ul>
<h2 id="7-exercise-the-cli"><a class="header" href="#7-exercise-the-cli">7. Exercise the CLI</a></h2>
<p>The <code>rustygpt</code> binary shares configuration and cookie handling with the server:</p>
<pre><code class="language-bash">cargo run -p rustygpt-cli -- login
cargo run -p rustygpt-cli -- chat --conversation &lt;conversation-uuid&gt;
cargo run -p rustygpt-cli -- follow --root &lt;thread-uuid&gt;
</code></pre>
<p><code>follow</code> connects to the SSE endpoint, reconstructs events, and prints deltas as they arrive. If you see <code>authentication required</code>
errors, confirm you completed the setup step and that <code>[features].auth_v1</code> is <code>true</code>.</p>
<h2 id="8-next-steps"><a class="header" href="#8-next-steps">8. Next steps</a></h2>
<ul>
<li>Review <a href="guide/local-dev.html">Local Development</a> for watcher workflows, linting, and debugging tips.</li>
<li>Explore <a href="guide/../reference/api.html">REST API</a> for a full endpoint catalogue and payload shapes.</li>
<li>Consult <a href="guide/../architecture/service-topology.html">Service Topology</a> to understand how the components interact at runtime.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="local-development"><a class="header" href="#local-development">Local Development</a></h1>
<blockquote>
<p>TL;DR – keep <code>config.toml</code> in sync with your environment, use <code>just dev</code> for paired watchers, and rely on the CLI for quick
smoke tests of authentication and streaming.</p>
</blockquote>
<h2 id="environment-configuration"><a class="header" href="#environment-configuration">Environment configuration</a></h2>
<p>All binaries load configuration through <code>rustygpt-shared::config::server::Config</code>. The loader merges:</p>
<ol>
<li>Built-in defaults selected by the active profile (Dev/Test/Prod)</li>
<li>Optional <code>config.toml</code> / <code>config.yaml</code> / <code>config.json</code></li>
<li>Environment variables such as <code>RUSTYGPT__SERVER__PORT=9000</code></li>
<li>CLI overrides (e.g. <code>cargo run -p rustygpt-server -- serve --port 9000</code>)</li>
</ol>
<p>Keep secrets out of the repo—override them with environment variables or a private <code>config.toml</code>. See
<a href="guide/../reference/config.html">Configuration</a> for the full key list.</p>
<h2 id="watcher-workflows"><a class="header" href="#watcher-workflows">Watcher workflows</a></h2>
<p>The <a href="guide/../../Justfile"><code>Justfile</code></a> orchestrates the common flows:</p>
<pre><code class="language-bash"># Run server + web watchers together (uses rustygpt-tools/confuse)
just dev

# Backend only hot-reload
just watch-server

# Run fmt, check, and clippy
just check
</code></pre>
<p><code>just dev</code> spawns two subprocesses:</p>
<ul>
<li><code>rustygpt-server</code> via <code>cargo watch -x 'run -- serve --port 8080'</code></li>
<li><code>rustygpt-web</code> via <code>trunk watch</code></li>
</ul>
<p>Logs stream to stdout so you can confirm when migrations finish (<code>db_bootstrap_*</code> metrics) and when the SSE hub accepts
connections.</p>
<h2 id="cli-smoke-tests"><a class="header" href="#cli-smoke-tests">CLI smoke tests</a></h2>
<p>The CLI binary lives at <code>rustygpt-cli</code>. Useful commands while iterating:</p>
<pre><code class="language-bash"># Launch the server directly from the CLI crate
cargo run -p rustygpt-cli -- serve --port 8080

# Generate the OpenAPI spec
cargo run -p rustygpt-cli -- spec openapi.yaml

# Generate config skeletons
cargo run -p rustygpt-cli -- config --format toml

# Manage sessions
cargo run -p rustygpt-cli -- login
cargo run -p rustygpt-cli -- me
cargo run -p rustygpt-cli -- logout
</code></pre>
<p>CLI commands reuse the same cookie jar as the web client. Cookies are stored under <code>~/.config/rustygpt/session.cookies</code> by
default (see <code>[cli]</code> in the configuration schema).</p>
<h2 id="debugging-tips"><a class="header" href="#debugging-tips">Debugging tips</a></h2>
<ul>
<li>Enable verbose tracing: <code>RUST_LOG=rustygpt_server=debug,tower_http=info just run-server</code></li>
<li>Inspect SSE payloads: <code>curl -N http://127.0.0.1:8080/api/stream/conversations/&lt;conversation-id&gt;</code> (requires an authenticated
session and <code>features.sse_v1 = true</code>)</li>
<li>Verify configuration resolution: <code>cargo run -p rustygpt-cli -- config --format json</code> and inspect the generated file</li>
<li>Regenerate database bindings or seed data by restarting the server; bootstrap scripts rerun automatically when the process
starts</li>
<li>Use <code>docker compose logs postgres</code> if migrations fail during bootstrap</li>
</ul>
<p>For operational playbooks (e.g. Docker deployment or rotating secrets) see the <a href="guide/../howto/index.html">How-to</a> section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concepts-overview"><a class="header" href="#concepts-overview">Concepts Overview</a></h1>
<p>This section explains the core ideas that appear across the server, web client, and CLI. Use it to understand the vocabulary
used in API responses and stream payloads before diving into the reference material.</p>
<ul>
<li><a href="concepts/reasoning-dag.html">Threaded conversations</a> describes how messages, threads, and <code>ConversationStreamEvent</code> values relate to each
other.</li>
<li><a href="concepts/dimensioned-entities.html">Shared models</a> covers the <code>rustygpt-shared</code> crate, focusing on how typed DTOs and enums keep clients
in sync with the server.</li>
</ul>
<p>Pair these concepts with the <a href="concepts/../architecture/index.html">Architecture</a> diagrams to see where each part lives at runtime.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="threaded-conversations"><a class="header" href="#threaded-conversations">Threaded conversations</a></h1>
<p>RustyGPT models chat history as <strong>threaded conversations</strong> stored in PostgreSQL. Each conversation has participants, invites,
thread roots, and replies. The server exposes this structure through the DTOs in <code>rustygpt-shared/src/models/chat.rs</code>.</p>
<h2 id="core-data-types"><a class="header" href="#core-data-types">Core data types</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Purpose</th><th>Defined in</th></tr></thead><tbody>
<tr><td><code>ConversationCreateRequest</code></td><td>Payload for creating a new conversation.</td><td><code>shared::models::chat</code></td></tr>
<tr><td><code>ThreadTreeResponse</code></td><td>Depth-first snapshot of a thread including metadata for each node.</td><td><code>shared::models::chat</code></td></tr>
<tr><td><code>MessageChunk</code></td><td>Persisted assistant output chunk (used when streaming replies).</td><td><code>shared::models::chat</code></td></tr>
<tr><td><code>ConversationStreamEvent</code></td><td>Enum describing SSE events (<code>thread.new</code>, <code>message.delta</code>, etc.).</td><td><code>shared::models::chat</code></td></tr>
</tbody></table>
</div>
<p>Each thread is anchored by a root message (<code>POST /api/threads/{conversation_id}/root</code>). Replies hang off the tree using parent
IDs (<code>POST /api/messages/{message_id}/reply</code>). The <code>ThreadTreeResponse</code> payload includes ancestry hints so clients can render the
structure without additional queries.</p>
<h2 id="streaming-lifecycle"><a class="header" href="#streaming-lifecycle">Streaming lifecycle</a></h2>
<p>When <code>features.sse_v1 = true</code>, the server emits <code>ConversationStreamEvent</code> variants via <code>StreamHub</code> (<code>handlers/streaming.rs</code>). The
naming mirrors the enum variants:</p>
<ul>
<li><code>thread.new</code> – new thread summary created</li>
<li><code>thread.activity</code> – updated <code>last_activity_at</code></li>
<li><code>message.delta</code> – incremental assistant tokens (<code>ChatDeltaChunk</code>)</li>
<li><code>message.done</code> – completion marker with usage stats</li>
<li><code>presence.update</code> – user presence heartbeat</li>
<li><code>typing.update</code> – typing indicator state</li>
<li><code>unread.update</code> – unread count per thread root</li>
<li><code>membership.changed</code> – conversation membership change</li>
<li><code>error</code> – terminal failure while streaming</li>
</ul>
<p>Events carry both the <code>conversation_id</code> and (when applicable) <code>root_id</code> so clients can scope updates precisely. SSE persistence is
optional: enable <code>[sse.persistence]</code> in configuration to record events in <code>rustygpt.sse_event_log</code> via
<code>services::sse_persistence</code> and replay them on reconnect.</p>
<h2 id="access-control"><a class="header" href="#access-control">Access control</a></h2>
<p>The chat service (<code>services::chat_service.rs</code>) enforces membership checks and rate limits before mutating data. Rate limit
profiles are backed by tables in <code>scripts/pg/schema/040_rate_limits.sql</code> and can be tuned via the admin API. Presence updates
mark the acting user online and emit events so all subscribers stay consistent.</p>
<p>For endpoint details see <a href="concepts/../reference/api.html">REST API</a>; for the transport-level diagram visit
<a href="concepts/../architecture/streaming.html">Streaming Delivery</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shared-models"><a class="header" href="#shared-models">Shared models</a></h1>
<p><code>rustygpt-shared</code> centralises the data structures consumed by the server, web client, and CLI. Keeping these DTOs in one crate
prevents drift between components and allows <code>serde</code> + <code>utoipa</code> derives to stay consistent.</p>
<h2 id="configuration-loader"><a class="header" href="#configuration-loader">Configuration loader</a></h2>
<p><code>src/config/server.rs</code> defines the <code>Config</code> struct and associated sub-structures (<code>ServerConfig</code>, <code>RateLimitConfig</code>,
<code>SseConfig</code>, etc.). Every binary loads configuration through <code>Config::load_config</code>, which merges defaults, optional files, and
environment overrides. Feature flags such as <code>features.auth_v1</code> gate server subsystems without requiring code changes.</p>
<h2 id="api-payloads"><a class="header" href="#api-payloads">API payloads</a></h2>
<p>The <code>src/models</code> directory contains strongly typed request/response structs:</p>
<ul>
<li><code>models/chat.rs</code> – conversations, threads, message payloads, and streaming events</li>
<li><code>models/oauth.rs</code> – GitHub/Apple OAuth exchanges</li>
<li><code>models/setup.rs</code> – first-time setup contract (<code>SetupRequest</code>, <code>SetupResponse</code>)</li>
<li><code>models/limits.rs</code> – rate limit admin DTOs (<code>CreateRateLimitProfileRequest</code>, <code>RateLimitAssignment</code>, ...)</li>
<li><code>models/session.rs</code> – session summaries returned by <code>/api/auth/*</code></li>
</ul>
<p>All types derive <code>Serialize</code>, <code>Deserialize</code>, and when relevant <code>utoipa::ToSchema</code> so the OpenAPI generator stays in sync.</p>
<h2 id="llm-abstractions"><a class="header" href="#llm-abstractions">LLM abstractions</a></h2>
<p><code>src/llms</code> exposes traits (<code>LLMProvider</code>, <code>LLMModel</code>) and helpers for llama.cpp integration. The server’s
<code>AssistantService</code> uses these traits to stream responses and emit metrics (<code>llm_model_cache_hits_total</code>, <code>llm_model_load_seconds</code>).
When you add a new provider, implement the traits here and update the configuration schema.</p>
<h2 id="why-it-matters"><a class="header" href="#why-it-matters">Why it matters</a></h2>
<ul>
<li><strong>Type safety</strong> – clients compile against the same structs the server uses, catching breaking changes early.</li>
<li><strong>Single-source documentation</strong> – OpenAPI docs and mdBook pages pull names directly from these types.</li>
<li><strong>Testing</strong> – shared fixtures in <code>shared::models</code> make it easier to write integration tests that cover both server handlers and
CLI commands.</li>
</ul>
<p>Whenever you extend the API, add or update the relevant struct in <code>rustygpt-shared</code> first, then regenerate the OpenAPI spec with
<code>cargo run -p rustygpt-cli -- spec</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-overview"><a class="header" href="#architecture-overview">Architecture Overview</a></h1>
<p>These chapters document the runtime architecture of RustyGPT: how the Axum server is composed, how the SSE stream hub works,
and how rate limiting integrates with PostgreSQL. Use them alongside the <a href="architecture/../concepts/index.html">concepts</a> and
<a href="architecture/../reference/index.html">reference</a> sections when exploring the code.</p>
<ul>
<li><a href="architecture/service-topology.html">Service topology</a></li>
<li><a href="architecture/streaming.html">Streaming delivery</a></li>
<li><a href="architecture/rate-limits.html">Rate-limit architecture</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="streaming-delivery"><a class="header" href="#streaming-delivery">Streaming delivery</a></h1>
<p>RustyGPT streams conversation activity to authenticated clients over Server-Sent Events (SSE). The implementation lives in
<code>rustygpt-server/src/handlers/streaming.rs</code> and is gated by <code>features.sse_v1</code>.</p>
<h2 id="flow"><a class="header" href="#flow">Flow</a></h2>
<pre class="mermaid">sequenceDiagram
  participant Client
  participant API as Axum /api
  participant Hub as StreamHub
  participant DB as rustygpt.sse_event_log

  Client-&gt;&gt;API: POST /api/threads/{conversation}/root
  API-&gt;&gt;Hub: publish ConversationStreamEvent
  Hub-&gt;&gt;Client: SSE event (thread.new)
  Note over Hub,DB: if persistence enabled
  Hub-&gt;&gt;DB: sp_record_sse_event
  Client-&gt;&gt;API: reconnect with Last-Event-ID
  API-&gt;&gt;Hub: subscribe(after)
  Hub-&gt;&gt;DB: fn_load_recent_sse_events
  DB--&gt;&gt;Hub: persisted events
  Hub--&gt;&gt;Client: replay then live stream
</pre>
<p>Clients subscribe to <code>/api/stream/conversations/:conversation_id</code>. The route is protected by the auth middleware when
<code>features.auth_v1</code> is enabled, so callers must present a valid session cookie (the CLI handles this automatically).</p>
<h2 id="event-payloads"><a class="header" href="#event-payloads">Event payloads</a></h2>
<p>Events are instances of <code>shared::models::ConversationStreamEvent</code> and are encoded as JSON envelopes with <code>type</code> and <code>payload</code>
fields. See <a href="architecture/../concepts/reasoning-dag.html">Threaded conversations</a> for the full list of variants.</p>
<p>The SSE handler assigns monotonically increasing sequence numbers per conversation. When persistence is enabled the sequence is
also stored in <code>rustygpt.sse_event_log</code>, allowing reconnecting clients to pass <code>Last-Event-ID</code> and receive any missed events
before resuming the live stream.</p>
<h2 id="persistence-and-retention"><a class="header" href="#persistence-and-retention">Persistence and retention</a></h2>
<p>Configure persistence via <code>[sse.persistence]</code> in <code>config.toml</code>:</p>
<pre><code class="language-toml">[sse.persistence]
enabled = true
max_events_per_user = 500
prune_batch_size = 100
retention_hours = 48
</code></pre>
<p><code>services::sse_persistence</code> stores events using the stored procedures in <code>scripts/pg/schema/050_sse_persistence.sql</code>. The pruning
logic runs after each insert to keep the table bounded.</p>
<h2 id="backpressure-handling"><a class="header" href="#backpressure-handling">Backpressure handling</a></h2>
<p>The in-memory queue for each conversation defaults to <code>channel_capacity = 128</code>. Configure behaviour under <code>[sse.backpressure]</code>:</p>
<ul>
<li><code>drop_strategy = "drop_tokens"</code> drops assistant token events first</li>
<li><code>drop_strategy = "drop_tokens_and_system"</code> also discards system events once the queue fills</li>
<li><code>warn_queue_ratio</code> controls when a warning is logged about queue pressure</li>
</ul>
<p>These settings keep hot conversations from exhausting memory while still delivering key state changes (presence, membership,
unread counters).</p>
<h2 id="client-responsibilities"><a class="header" href="#client-responsibilities">Client responsibilities</a></h2>
<ul>
<li>Reconnect with <code>Last-Event-ID</code> so the server can replay persisted events when available</li>
<li>Handle <code>401</code> responses by re-running the session refresh flow (<code>/api/auth/refresh</code>); the CLI and web client do this
automatically</li>
<li>Clear typing state on <code>typing.update</code> and update unread counters when <code>unread.update</code> arrives</li>
</ul>
<p>Use <a href="architecture/../reference/api.html">REST API</a> endpoints to backfill state when the requested <code>Last-Event-ID</code> falls outside the retention
window.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="service-topology"><a class="header" href="#service-topology">Service topology</a></h1>
<p>RustyGPT is composed of a single Axum process backed by PostgreSQL. The web client and CLI talk to the same REST + SSE surface.</p>
<h2 id="components"><a class="header" href="#components">Components</a></h2>
<ul>
<li><strong>Axum API (<code>rustygpt-server</code>)</strong> – exposes <code>/api/*</code> endpoints, authentication middleware, rate limiting, SSE, OpenAPI docs,
health probes, metrics, and static file hosting.</li>
<li><strong>PostgreSQL</strong> – stores users, sessions, conversations, threads, SSE history, and rate-limit configuration. Schema and stored
procedures live in <code>scripts/pg</code> and are applied automatically during bootstrap.</li>
<li><strong>SSE StreamHub</strong> – in-memory fan-out implemented in <code>handlers/streaming.rs</code>, optionally persisting events through
<code>services::sse_persistence</code>.</li>
<li><strong>Yew SPA (<code>rustygpt-web</code>)</strong> – compiled to WebAssembly with Trunk. <code>src/api.rs</code> handles authentication, CSRF, SSE reconnection,
and REST calls for conversations/threads.</li>
<li><strong>CLI (<code>rustygpt-cli</code>)</strong> – shares configuration and models with the server. Provides helper commands for session management,
SSE following, and OpenAPI/config generation.</li>
</ul>
<h2 id="data-flow"><a class="header" href="#data-flow">Data flow</a></h2>
<pre class="mermaid">flowchart LR
  subgraph Clients
    web[Yew web app]
    cli[CLI]
  end
  api[Axum /api]
  stream[StreamHub]
  db[(PostgreSQL)]

  web --&gt; api
  cli --&gt; api
  api --&gt; db
  api --&gt; stream
  stream --&gt; web
  stream --&gt; cli
</pre>
<p><em>Requests hit the Axum router, which talks to PostgreSQL via SQLx and fans out live events via StreamHub. Clients subscribe to
<code>/api/stream/conversations/:conversation_id</code> to receive updates.</em></p>
<h2 id="feature-flags"><a class="header" href="#feature-flags">Feature flags</a></h2>
<p>Many subsystems are gated by <code>[features]</code> in configuration:</p>
<ul>
<li><code>auth_v1</code> – enables session middleware, <code>/api/auth/*</code>, protected routes, and the rate-limit admin API</li>
<li><code>sse_v1</code> – enables the SSE route and persistence options</li>
<li><code>well_known</code> – serves <code>.well-known/*</code> entries from the config</li>
</ul>
<p>Toggle these flags without recompiling the binaries.</p>
<h2 id="scaling-notes"><a class="header" href="#scaling-notes">Scaling notes</a></h2>
<p>The server is stateless apart from in-memory SSE buffers. For horizontal scaling you must either:</p>
<ul>
<li>Disable persistence and tolerate best-effort delivery, or</li>
<li>Configure <code>[sse.persistence]</code> so each instance replays from PostgreSQL on reconnect</li>
</ul>
<p>Rate limiting already supports multi-instance deployments because configuration is stored in the database and periodically
reloaded (<code>RateLimitState::reload_from_db</code>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rate-limit-architecture"><a class="header" href="#rate-limit-architecture">Rate-limit architecture</a></h1>
<p>RustyGPT enforces per-route throttling using a leaky-bucket strategy implemented in <code>middleware::rate_limit</code>. Configuration
comes from two tables managed by stored procedures in <code>scripts/pg/procs/034_limits.sql</code>.</p>
<h2 id="data-model"><a class="header" href="#data-model">Data model</a></h2>
<ul>
<li><code>rustygpt.rate_limit_profiles</code> – named profiles containing algorithm + JSON parameters (currently <code>gcra</code> style with
<code>requests_per_second</code> / <code>burst</code> options).</li>
<li><code>rustygpt.rate_limit_assignments</code> – maps HTTP method + path pattern to a profile.</li>
<li><code>rustygpt.message_rate_limits</code> – per-user, per-conversation state used by <code>sp_user_can_post</code> to throttle message posting.</li>
</ul>
<p><code>RateLimitState::reload_from_db</code> loads profiles and assignments into memory. The admin API under <code>/api/admin/limits/*</code> can
create, update, or delete records at runtime; after each change the state refreshes automatically.</p>
<h2 id="matching-logic"><a class="header" href="#matching-logic">Matching logic</a></h2>
<p><code>enforce_rate_limits</code> computes a cache key as <code>"{METHOD} {path}"</code> and finds the first matching pattern. Supported patterns:</p>
<ul>
<li>Exact path matches (<code>/api/messages/{id}/reply</code> becomes <code>/api/messages/:id/reply</code> in the database)</li>
<li><code>*</code> suffix for prefixes (e.g. <code>/api/admin/*</code>)</li>
</ul>
<p>If no assignment matches, the middleware falls back to the default strategy derived from <code>[rate_limits.default_rps]</code> and
<code>[rate_limits.burst]</code>. Login routes (<code>/api/auth/login</code>) use the dedicated <code>auth_login_per_ip_per_min</code> limiter.</p>
<h2 id="metrics-and-headers"><a class="header" href="#metrics-and-headers">Metrics and headers</a></h2>
<p>When a request is evaluated the middleware records:</p>
<ul>
<li><code>http_rate_limit_requests_total{profile,result}</code> – allowed vs denied counts</li>
<li><code>http_rate_limit_remaining{profile}</code> – remaining tokens after the decision</li>
<li><code>http_rate_limit_reset_seconds{profile}</code> – seconds until the bucket refills</li>
<li><code>rustygpt_limits_profiles</code> / <code>rustygpt_limits_assignments</code> – gauges updated on reload</li>
</ul>
<p>Responses include the standard headers <code>RateLimit-Limit</code>, <code>RateLimit-Remaining</code>, <code>RateLimit-Reset</code>, and
<code>X-RateLimit-Profile</code> so clients can react accordingly.</p>
<h2 id="admin-api-payloads"><a class="header" href="#admin-api-payloads">Admin API payloads</a></h2>
<p>All admin payloads live in <code>shared::models::limits</code>:</p>
<ul>
<li><code>CreateRateLimitProfileRequest</code></li>
<li><code>UpdateRateLimitProfileRequest</code></li>
<li><code>AssignRateLimitRequest</code></li>
<li><code>RateLimitProfile</code> / <code>RateLimitAssignment</code></li>
</ul>
<p>These endpoints require an authenticated session with the <code>admin</code> role (<code>handlers/admin_limits.rs</code>).</p>
<h2 id="conversation-posting-limits"><a class="header" href="#conversation-posting-limits">Conversation posting limits</a></h2>
<p><code>ChatService::post_root_message</code> and <code>ChatService::reply_message</code> call <code>sp_user_can_post</code>, which enforces a GCRA window per
<code>(user_id, conversation_id)</code> using <code>rustygpt.message_rate_limits</code>. Tweak the <code>conversation.post</code> profile via SQL or the admin
API to adjust posting cadence.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reference-overview"><a class="header" href="#reference-overview">Reference Overview</a></h1>
<p>Authoritative details for RustyGPT’s public surfaces:</p>
<ul>
<li><a href="reference/authentication.html">Authentication</a> – session cookies, setup flow, and rotation behaviour</li>
<li><a href="reference/api.html">REST API</a> – endpoint catalogue grouped by feature area</li>
<li><a href="reference/config.html">Configuration</a> – <code>config.toml</code> structure and environment overrides</li>
</ul>
<p>For operational workflows see <a href="reference/../howto/index.html">How-to</a>; for high-level design context visit the
<a href="reference/../architecture/index.html">Architecture</a> section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="authentication"><a class="header" href="#authentication">Authentication</a></h1>
<p>RustyGPT uses cookie-based sessions backed by PostgreSQL. Session management lives in <code>rustygpt-server/src/auth/session.rs</code> and
is exposed through <code>/api/auth/*</code> handlers when <code>features.auth_v1 = true</code>.</p>
<h2 id="session-lifecycle"><a class="header" href="#session-lifecycle">Session lifecycle</a></h2>
<ol>
<li><strong>Setup</strong> – <code>POST /api/setup</code> hashes the supplied password and inserts the first user (admin + member roles). Further calls
are rejected.</li>
<li><strong>Login</strong> – <code>POST /api/auth/login</code> verifies credentials via <code>sp_auth_login</code>. Successful responses include:
<ul>
<li><code>Set-Cookie: SESSION_ID=...; HttpOnly; Secure?; SameSite=Lax</code></li>
<li><code>Set-Cookie: CSRF-TOKEN=...; SameSite=Strict</code></li>
<li><code>X-Session-Rotated: 1</code></li>
</ul>
</li>
<li><strong>Authenticated requests</strong> – non-GET operations must include the CSRF header <code>X-CSRF-TOKEN</code> with the cookie value. The web
client (<code>rustygpt-web/src/api.rs</code>) and CLI handle this automatically.</li>
<li><strong>Refresh</strong> – <code>POST /api/auth/refresh</code> rotates cookies inside the idle window (default 8 hours). If either idle or absolute
expiry is exceeded, the call returns <code>401 session_expired</code>.</li>
<li><strong>Logout</strong> – <code>POST /api/auth/logout</code> clears the session and CSRF cookies.</li>
</ol>
<p>Sessions are stored in <code>rustygpt.user_sessions</code>. The idle and absolute windows come from <code>[session]</code> in configuration. When
<code>max_sessions_per_user</code> is set the newest session evicts the oldest via <code>sp_auth_login</code>.</p>
<h2 id="cookie-configuration"><a class="header" href="#cookie-configuration">Cookie configuration</a></h2>
<p><code>config.toml</code> controls cookie behaviour:</p>
<pre><code class="language-toml">[session]
idle_seconds = 28800
absolute_seconds = 604800
session_cookie_name = "SESSION_ID"
csrf_cookie_name = "CSRF-TOKEN"
max_sessions_per_user = 5

[security.cookie]
domain = ""
secure = false
same_site = "lax"

[security.csrf]
cookie_name = "CSRF-TOKEN"
header_name = "X-CSRF-TOKEN"
enabled = true
</code></pre>
<p>Adjust <code>security.cookie.secure</code> and <code>security.cookie.domain</code> for production deployments. When <code>security.csrf.enabled = false</code>
the middleware skips header validation (useful for service-to-service calls but not recommended for browsers).</p>
<h2 id="cli-workflow"><a class="header" href="#cli-workflow">CLI workflow</a></h2>
<p>The CLI wraps the same endpoints:</p>
<pre><code class="language-bash">cargo run -p rustygpt-cli -- login
cargo run -p rustygpt-cli -- me
cargo run -p rustygpt-cli -- logout
</code></pre>
<p>Cookies are stored at <code>~/.config/rustygpt/session.cookies</code> by default (see <code>[cli.session_store]</code>). The <code>follow</code> and <code>chat</code>
commands automatically attach the CSRF header when present.</p>
<h2 id="observability"><a class="header" href="#observability">Observability</a></h2>
<p>Authentication currently relies on logs for troubleshooting. Set <code>RUST_LOG=rustygpt_server=debug</code> to trace session decisions
(<code>SessionService::authenticate</code>, <code>SessionService::refresh_session</code>). Prometheus metrics for auth flows are not yet implemented.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rest-api"><a class="header" href="#rest-api">REST API</a></h1>
<p>All endpoints are served under <code>/api</code> unless noted otherwise. Session cookies and CSRF headers are required for non-authenticated
GET requests when <code>features.auth_v1</code> is enabled. The OpenAPI schema is generated from <code>rustygpt-server/src/openapi.rs</code> and can
be exported with <code>cargo run -p rustygpt-cli -- spec</code>.</p>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Path</th><th>Description</th></tr></thead><tbody>
<tr><td>GET</td><td><code>/api/setup</code></td><td>Returns <code>{ "is_setup": bool }</code> by calling <code>is_setup()</code> in PostgreSQL.</td></tr>
<tr><td>POST</td><td><code>/api/setup</code></td><td>Creates the first administrator account (see <code>scripts/pg/procs/010_auth.sql::init_setup</code>). Subsequent calls return <code>400</code>.</td></tr>
</tbody></table>
</div>
<h2 id="authentication-1"><a class="header" href="#authentication-1">Authentication</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Path</th><th>Description</th></tr></thead><tbody>
<tr><td>POST</td><td><code>/api/auth/login</code></td><td>Email/password login. Returns <code>LoginResponse</code> with session + CSRF cookies.</td></tr>
<tr><td>POST</td><td><code>/api/auth/logout</code></td><td>Revokes the current session. Requires CSRF header.</td></tr>
<tr><td>POST</td><td><code>/api/auth/refresh</code></td><td>Rotates session cookies inside the idle window.</td></tr>
<tr><td>GET</td><td><code>/api/auth/me</code></td><td>Returns <code>MeResponse</code> (requires authenticated session).</td></tr>
</tbody></table>
</div>
<h3 id="oauth-helpers"><a class="header" href="#oauth-helpers">OAuth helpers</a></h3>
<p>Handlers in <code>handlers/github_auth.rs</code> and <code>handlers/apple_auth.rs</code> expose optional OAuth flows when credentials are present:</p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Path</th><th>Notes</th></tr></thead><tbody>
<tr><td>GET</td><td><code>/api/oauth/github</code></td><td>Returns an authorization URL based on <code>GITHUB_*</code> environment variables.</td></tr>
<tr><td>GET</td><td><code>/api/oauth/github/callback</code></td><td>Exchanges the code for a session via <code>ProductionOAuthService</code>.</td></tr>
<tr><td>POST</td><td><code>/api/oauth/github/manual</code></td><td>Developer helper that accepts a raw auth code.</td></tr>
<tr><td>GET</td><td><code>/api/oauth/apple</code></td><td>Same as GitHub but for Apple.</td></tr>
<tr><td>GET</td><td><code>/api/oauth/apple/callback</code></td><td>Callback handler.</td></tr>
<tr><td>POST</td><td><code>/api/oauth/apple/manual</code></td><td>Manual exchange helper.</td></tr>
</tbody></table>
</div>
<h2 id="conversations--membership"><a class="header" href="#conversations--membership">Conversations &amp; membership</a></h2>
<p>Routes implemented in <code>handlers/conversations.rs</code>:</p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Path</th><th>Description</th></tr></thead><tbody>
<tr><td>POST</td><td><code>/api/conversations</code></td><td>Create a new conversation.</td></tr>
<tr><td>POST</td><td><code>/api/conversations/{conversation_id}/participants</code></td><td>Invite/add a participant. Emits membership + presence SSE events.</td></tr>
<tr><td>DELETE</td><td><code>/api/conversations/{conversation_id}/participants/{user_id}</code></td><td>Remove a participant.</td></tr>
<tr><td>POST</td><td><code>/api/conversations/{conversation_id}/invites</code></td><td>Create an invite token.</td></tr>
<tr><td>POST</td><td><code>/api/invites/accept</code></td><td>Accept an invite token.</td></tr>
<tr><td>POST</td><td><code>/api/invites/{token}/revoke</code></td><td>Revoke an invite token.</td></tr>
<tr><td>GET</td><td><code>/api/conversations/{conversation_id}/threads</code></td><td>List thread summaries (supports <code>after</code> + <code>limit</code> query params).</td></tr>
<tr><td>GET</td><td><code>/api/conversations/{conversation_id}/unread</code></td><td>Return unread counts per thread.</td></tr>
</tbody></table>
</div>
<h2 id="threads--messages"><a class="header" href="#threads--messages">Threads &amp; messages</a></h2>
<p>Routes from <code>handlers/threads.rs</code>:</p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Path</th><th>Description</th></tr></thead><tbody>
<tr><td>GET</td><td><code>/api/threads/{root_id}/tree</code></td><td>Depth-first thread slice (<code>cursor_path</code> + <code>limit</code> optional).</td></tr>
<tr><td>POST</td><td><code>/api/threads/{conversation_id}/root</code></td><td>Create a new thread root. Triggers assistant streaming when role = <code>assistant</code>.</td></tr>
<tr><td>POST</td><td><code>/api/messages/{parent_id}/reply</code></td><td>Reply to an existing message.</td></tr>
<tr><td>GET</td><td><code>/api/messages/{message_id}/chunks</code></td><td>Retrieve persisted assistant chunks.</td></tr>
<tr><td>POST</td><td><code>/api/threads/{root_id}/read</code></td><td>Mark thread as read (<code>MarkThreadReadRequest</code>).</td></tr>
<tr><td>POST</td><td><code>/api/messages/{message_id}/delete</code></td><td>Soft-delete a message.</td></tr>
<tr><td>POST</td><td><code>/api/messages/{message_id}/restore</code></td><td>Restore a previously deleted message.</td></tr>
<tr><td>POST</td><td><code>/api/messages/{message_id}/edit</code></td><td>Replace message content.</td></tr>
<tr><td>POST</td><td><code>/api/typing</code></td><td>Set typing state (<code>TypingRequest</code>).</td></tr>
<tr><td>POST</td><td><code>/api/presence/heartbeat</code></td><td>Update presence heartbeat.</td></tr>
</tbody></table>
</div>
<h2 id="streaming"><a class="header" href="#streaming">Streaming</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Path</th><th>Description</th></tr></thead><tbody>
<tr><td>GET</td><td><code>/api/stream/conversations/{conversation_id}</code></td><td>SSE endpoint producing <code>ConversationStreamEvent</code> values. Requires session cookie and (optionally) <code>Last-Event-ID</code>.</td></tr>
</tbody></table>
</div>
<h2 id="copilot-compatible-endpoints"><a class="header" href="#copilot-compatible-endpoints">Copilot-compatible endpoints</a></h2>
<p>These helpers live in <code>handlers/copilot.rs</code> and provide simple echo responses for integration tests:</p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Path</th><th>Description</th></tr></thead><tbody>
<tr><td>GET</td><td><code>/v1/models</code></td><td>Returns <code>ModelsResponse</code> with two static models (<code>gpt-4</code>, <code>gpt-3.5</code>).</td></tr>
<tr><td>POST</td><td><code>/v1/chat/completions</code></td><td>Echoes provided messages as assistant responses (<code>ChatCompletionResponse</code>).</td></tr>
</tbody></table>
</div>
<h2 id="admin-rate-limit-api"><a class="header" href="#admin-rate-limit-api">Admin rate limit API</a></h2>
<p>Available when <code>features.auth_v1 = true</code> and <code>rate_limits.admin_api_enabled = true</code> (<code>handlers/admin_limits.rs</code>):</p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Path</th><th>Description</th></tr></thead><tbody>
<tr><td>GET</td><td><code>/api/admin/limits/profiles</code></td><td>List profiles.</td></tr>
<tr><td>POST</td><td><code>/api/admin/limits/profiles</code></td><td>Create a profile.</td></tr>
<tr><td>PUT</td><td><code>/api/admin/limits/profiles/{id}</code></td><td>Update profile parameters/description.</td></tr>
<tr><td>DELETE</td><td><code>/api/admin/limits/profiles/{id}</code></td><td>Delete a profile (fails if still assigned).</td></tr>
<tr><td>GET</td><td><code>/api/admin/limits/assignments</code></td><td>List route assignments.</td></tr>
<tr><td>POST</td><td><code>/api/admin/limits/assignments</code></td><td>Assign a profile to a route.</td></tr>
<tr><td>DELETE</td><td><code>/api/admin/limits/assignments/{id}</code></td><td>Remove an assignment.</td></tr>
</tbody></table>
</div>
<h2 id="health-and-observability"><a class="header" href="#health-and-observability">Health and observability</a></h2>
<p>Outside of the <code>/api</code> prefix, the server exposes:</p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Path</th><th>Description</th></tr></thead><tbody>
<tr><td>GET</td><td><code>/healthz</code></td><td>Liveness probe.</td></tr>
<tr><td>GET</td><td><code>/readyz</code></td><td>Readiness probe (verifies PostgreSQL bootstrap).</td></tr>
<tr><td>GET</td><td><code>/metrics</code></td><td>Prometheus metrics via <code>metrics-exporter-prometheus</code>.</td></tr>
<tr><td>GET</td><td><code>/.well-known/{path}</code></td><td>Served when <code>features.well_known = true</code>; entries configured via <code>[well_known.entries]</code>.</td></tr>
<tr><td>GET</td><td><code>/openapi.json</code> / <code>/openapi.yaml</code></td><td>Generated OpenAPI spec.</td></tr>
</tbody></table>
</div>
<p>Refer to <a href="reference/authentication.html">Authentication</a> for cookie details and <a href="reference/config.html">Configuration</a> for the relevant keys.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<p>RustyGPT uses a layered configuration loader (<code>rustygpt-shared::config::server::Config</code>). Defaults are determined by the active
profile (Dev/Test/Prod), then merged with an optional file and environment overrides. CLI flags can override specific values
(e.g. <code>--port</code>).</p>
<h2 id="loading-order"><a class="header" href="#loading-order">Loading order</a></h2>
<ol>
<li>Profile defaults (<code>Config::default_for_profile(Profile::Dev)</code>)</li>
<li>Optional config file (<code>config.toml</code>, <code>config.yaml</code>, or <code>config.json</code>)</li>
<li>Environment variables using double underscores (e.g. <code>RUSTYGPT__SERVER__PORT=9000</code>)</li>
<li>CLI overrides (currently the server/CLI <code>--port</code> flag)</li>
</ol>
<p><code>Config::load_config(path, override_port)</code> performs this merge and validates required fields.</p>
<h2 id="key-sections"><a class="header" href="#key-sections">Key sections</a></h2>
<h3 id="logging"><a class="header" href="#logging"><code>[logging]</code></a></h3>
<pre><code class="language-toml">[logging]
level = "info"        # tracing level passed to tracing-subscriber
format = "text"        # "text" or "json"
</code></pre>
<h3 id="server"><a class="header" href="#server"><code>[server]</code></a></h3>
<pre><code class="language-toml">[server]
host = "127.0.0.1"
port = 8080
public_base_url = "http://localhost:8080"
request_id_header = "x-request-id"

[server.cors]
allowed_origins = ["http://localhost:3000", "http://127.0.0.1:3000"]
allow_credentials = false
max_age_seconds = 600
</code></pre>
<p><code>public_base_url</code> is derived automatically when not supplied (scheme depends on profile). <code>request_id_header</code> controls which
header the middleware reads when assigning request IDs.</p>
<h3 id="security"><a class="header" href="#security"><code>[security]</code></a></h3>
<pre><code class="language-toml">[security.hsts]
enabled = false
max_age_seconds = 63072000
include_subdomains = true
preload = false

[security.cookie]
domain = ""
secure = false
same_site = "lax"

[security.csrf]
cookie_name = "CSRF-TOKEN"
header_name = "X-CSRF-TOKEN"
enabled = true
</code></pre>
<h3 id="rate_limits"><a class="header" href="#rate_limits"><code>[rate_limits]</code></a></h3>
<pre><code class="language-toml">[rate_limits]
auth_login_per_ip_per_min = 10
default_rps = 50.0
burst = 100
admin_api_enabled = false
</code></pre>
<p>When <code>admin_api_enabled = true</code> the <code>/api/admin/limits/*</code> routes become available.</p>
<h3 id="session"><a class="header" href="#session"><code>[session]</code></a></h3>
<pre><code class="language-toml">[session]
idle_seconds = 28800
absolute_seconds = 604800
session_cookie_name = "SESSION_ID"
csrf_cookie_name = "CSRF-TOKEN"
max_sessions_per_user = 5
</code></pre>
<p>Set <code>max_sessions_per_user = 0</code> (or <code>null</code>) to disable automatic eviction.</p>
<h3 id="oauth"><a class="header" href="#oauth"><code>[oauth]</code></a></h3>
<pre><code class="language-toml">[oauth]
redirect_base = "http://localhost:8080/api/auth/github/callback"

[oauth.github]
client_id = "..."
client_secret = "..."
</code></pre>
<p>If <code>oauth.github</code> is omitted the GitHub endpoints still respond but return empty URLs. Apple support reads <code>APPLE_*</code>
environment variables directly in the handler.</p>
<h3 id="db"><a class="header" href="#db"><code>[db]</code></a></h3>
<pre><code class="language-toml">[db]
url = "postgres://tinroof:rusty@localhost/rustygpt_dev"
statement_timeout_ms = 5000
max_connections = 10
bootstrap_path = "../scripts/pg"
</code></pre>
<p><code>bootstrap_path</code> points to the directory containing <code>schema/</code>, <code>procedures/</code>, <code>indexes/</code>, and <code>seed/</code> folders.</p>
<h3 id="sse"><a class="header" href="#sse"><code>[sse]</code></a></h3>
<pre><code class="language-toml">[sse]
heartbeat_seconds = 20
channel_capacity = 128
id_prefix = "evt_"

[sse.persistence]
enabled = false
max_events_per_user = 500
prune_batch_size = 100
retention_hours = 48

[sse.backpressure]
drop_strategy = "drop_tokens"
warn_queue_ratio = 0.75
</code></pre>
<h3 id="features"><a class="header" href="#features"><code>[features]</code></a></h3>
<pre><code class="language-toml">[features]
auth_v1 = true
sse_v1 = true
well_known = true
</code></pre>
<p>Flags gate optional subsystems without recompiling the binary.</p>
<h3 id="cli-and-web"><a class="header" href="#cli-and-web"><code>[cli]</code> and <code>[web]</code></a></h3>
<pre><code class="language-toml">[cli]
session_store = "~/.config/rustygpt/session.cookies"

[web]
static_dir = "../rustygpt-web/dist"
spa_index = "../rustygpt-web/dist/index.html"
</code></pre>
<h3 id="llm"><a class="header" href="#llm"><code>[llm]</code></a></h3>
<p><code>Config</code> embeds <code>LLMConfiguration</code> from <code>rustygpt-shared::config::llm</code>. Use it to describe llama.cpp models/providers:</p>
<pre><code class="language-toml">[llm.global_settings]
persist_stream_chunks = true

[llm.providers.default]
provider_type = "llama_cpp"
model_path = "./models/your-model.gguf"
</code></pre>
<p>See <code>rustygpt-shared/src/config/llm.rs</code> for the full schema.</p>
<h2 id="environment-variable-syntax"><a class="header" href="#environment-variable-syntax">Environment variable syntax</a></h2>
<p>Nested keys map to uppercase names with double underscores. Examples:</p>
<ul>
<li><code>RUSTYGPT__SERVER__PORT=9001</code></li>
<li><code>RUSTYGPT__SECURITY__COOKIE__SECURE=true</code></li>
<li><code>RUSTYGPT__FEATURES__SSE_V1=true</code></li>
</ul>
<p>Booleans and numbers follow standard Rust parsing rules. Paths can be relative or absolute.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-overview"><a class="header" href="#how-to-overview">How-to Overview</a></h1>
<p>Task-focused guides for operating RustyGPT. These assume you already understand the system from the <a href="howto/../guide/index.html">Guides</a>
and <a href="howto/../reference/index.html">Reference</a> sections.</p>
<ul>
<li><a href="howto/docker-deploy.html">Docker Deploy</a> – build/publish images and run Compose.</li>
<li><a href="howto/rotate-secrets.html">Rotate Secrets</a> – refresh credentials and validate sessions.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="docker-deploy"><a class="header" href="#docker-deploy">Docker deploy</a></h1>
<p>This guide covers building the RustyGPT container image and running it alongside PostgreSQL with Docker Compose.</p>
<h2 id="build-the-image"><a class="header" href="#build-the-image">Build the image</a></h2>
<p>The repository ships a multi-stage <a href="howto/../../Dockerfile"><code>Dockerfile</code></a> that builds the workspace and bundles the server binary plus
static assets:</p>
<pre><code class="language-bash">docker build -t rustygpt/server:latest -f Dockerfile .
</code></pre>
<p>Set <code>BUILD_PROFILE=release</code> to compile with optimisations. The final image exposes the server on port <code>8080</code>.</p>
<h2 id="compose-stack"><a class="header" href="#compose-stack">Compose stack</a></h2>
<p><a href="howto/../../docker-compose.yaml"><code>docker-compose.yaml</code></a> defines two services:</p>
<ul>
<li><code>backend</code> – builds from the Dockerfile (target <code>runtime</code>). Environment variables include <code>DATABASE_URL</code>, OAuth credentials, and
feature toggles. Update them to match your deployment.</li>
<li><code>postgres</code> – <code>postgres:17-alpine</code> with credentials matching <code>config.example.toml</code>.</li>
</ul>
<p>Bring the stack up:</p>
<pre><code class="language-bash">docker compose up --build
</code></pre>
<p>The compose file mounts <code>./.data/postgres</code> for database storage and <code>./.data/postgres-init</code> for init scripts. To reuse the
workspace schema, copy the contents of <code>scripts/pg</code> into that directory before the first run:</p>
<pre><code class="language-bash">mkdir -p .data/postgres-init
cp -r scripts/pg/* .data/postgres-init/
</code></pre>
<p>Alternatively, rely on the server’s bootstrap runner by exposing the same directory inside the backend container and pointing
<code>[db].bootstrap_path</code> at it.</p>
<h2 id="configuration-and-secrets"><a class="header" href="#configuration-and-secrets">Configuration and secrets</a></h2>
<ul>
<li>Copy <code>config.example.toml</code> to a volume or bake it into the image and set <code>RUSTYGPT__CONFIG</code> variables as needed.</li>
<li>Provide OAuth credentials (<code>GITHUB_*</code>, <code>APPLE_*</code>) if you plan to use those flows; otherwise the endpoints return placeholder
URLs.</li>
<li>Set <code>features.auth_v1</code>, <code>features.sse_v1</code>, and <code>features.well_known</code> to <code>true</code> via environment variables or the config file.</li>
<li>If running behind TLS terminate HTTPS at the reverse proxy and set <code>server.public_base_url</code> to the external URL.</li>
</ul>
<h2 id="post-deployment-checks"><a class="header" href="#post-deployment-checks">Post-deployment checks</a></h2>
<ol>
<li>Hit <code>http://HOST:8080/healthz</code> and <code>http://HOST:8080/readyz</code> until both return <code>200</code>.</li>
<li>POST to <code>/api/setup</code> to create the initial admin account.</li>
<li>Use the CLI container (or a local build) to log in: <code>docker compose exec backend rustygpt login</code>.</li>
<li>Visit <code>/metrics</code> and confirm counters increment when making requests.</li>
<li>If using the web UI, serve the <code>rustygpt-web</code> build either from the same container (set <code>[web.static_dir]</code>) or via a separate
static host.</li>
</ol>
<h2 id="rollback"><a class="header" href="#rollback">Rollback</a></h2>
<p>Tag each release in your registry. To roll back:</p>
<pre><code class="language-bash">docker compose pull backend:previous-tag
docker compose up -d backend
</code></pre>
<p>The PostgreSQL data directory is persisted on disk so sessions and conversations remain intact.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rotate-secrets"><a class="header" href="#rotate-secrets">Rotate secrets</a></h1>
<p>Use this runbook to update credentials (database passwords, OAuth secrets, session keys) while keeping RustyGPT online.</p>
<h2 id="preparation"><a class="header" href="#preparation">Preparation</a></h2>
<ol>
<li>Inventory the secrets in use (e.g. <code>DATABASE_URL</code>, <code>GITHUB_CLIENT_SECRET</code>, config entries under <code>[security.cookie]</code>).</li>
<li>Update your secret manager or environment files with new values, but do not apply them yet.</li>
<li>Coordinate a maintenance window if session cookie rotation is expected to log users out.</li>
</ol>
<h2 id="rotation-steps"><a class="header" href="#rotation-steps">Rotation steps</a></h2>
<ol>
<li><strong>Stage</strong> – write new values to your secret store or <code>.env</code> file.</li>
<li><strong>Deploy</strong> – restart the server with updated environment variables/config (<code>docker compose restart backend</code> or rolling
restart in your orchestrator). The bootstrap runner is idempotent, so restarting is safe.</li>
<li><strong>Verify</strong> – run smoke tests:
<pre><code class="language-bash">cargo run -p rustygpt-cli -- login
cargo run -p rustygpt-cli -- me
curl -sSf http://HOST:8080/readyz
</code></pre>
</li>
<li><strong>Cleanup</strong> – remove old secrets from the manager and audit logs for unexpected errors.</li>
</ol>
<p>Session cookies are independent of database passwords or OAuth secrets. If you change <code>[security.cookie]</code> settings (e.g. enable
<code>secure</code> or change <code>session_cookie_name</code>), expect users to sign in again.</p>
<h2 id="observability-1"><a class="header" href="#observability-1">Observability</a></h2>
<ul>
<li>Watch application logs for <code>SessionService</code> warnings.</li>
<li>Confirm <code>http_rate_limit_requests_total</code> continues to increment after the restart.</li>
<li>Verify the CLI can still access streaming endpoints (<code>cargo run -p rustygpt-cli -- follow --root &lt;id&gt;</code>).</li>
</ul>
<h2 id="incident-response"><a class="header" href="#incident-response">Incident response</a></h2>
<p>If a rotation fails:</p>
<ol>
<li>Roll back to the previous secret values and restart the server.</li>
<li>Capture logs around the failure (authentication errors, database connection failures, etc.).</li>
<li>File an issue or ADR documenting the change and follow-up actions.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="release-notes"><a class="header" href="#release-notes">Release notes</a></h1>
<p>The authoritative changelog lives in <a href="changelog/../../CHANGELOG.html"><code>CHANGELOG.md</code></a>. No tagged releases have been published yet; the
<code>[Unreleased]</code> section tracks ongoing development across the workspace crates.</p>
<p>When a release is tagged (<code>vMAJOR.MINOR.PATCH</code>) update the changelog and, if applicable, regenerate the docs index with
<code>just docs-index</code> so the summaries reflect the new features.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="scripts/mermaid.min.js"></script>
        <script src="scripts/mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
